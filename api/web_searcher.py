from llm_service import prompt_llm, summarize # Import the LLM service
import re
import json
from bs4 import BeautifulSoup
from duckduckgo_search import DDGS
from markdownify import MarkdownConverter
import requests
import datetime
import textwrap
import logging

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s]: %(message)s")


safety_settings = [
    {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
]

class WebSearch:
    """Perform DuckDuckGo searches and fetch web content."""

    def __init__(self, verbose=False, retry_limit=3):
        self.verbose = verbose
        self.retry_limit = retry_limit

    def fetch(self, url):
        """Fetch a URL with retry logic."""
        for attempt in range(self.retry_limit):
            try:
                if self.verbose:
                    logging.info(f"Attempting to fetch URL: {url} (Attempt {attempt + 1})")
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    return response.content
                logging.warning(f"Failed to fetch {url}: HTTP {response.status_code}")
            except requests.RequestException as e:
                logging.warning(f"Error fetching {url}: {e}")
            logging.info(f"Retrying ({attempt + 1}/{self.retry_limit})...")
        logging.error(f"Failed to fetch URL after {self.retry_limit} attempts: {url}")
        return None

    def ddg_search(self, topic):
        """Search DuckDuckGo for a topic."""
        try:
            if self.verbose:
                logging.info(f"Searching DuckDuckGo for: {topic}")
            return DDGS().text(topic)
        except Exception as e:
            logging.error(f"Error during DuckDuckGo search for '{topic}': {e}")
            return []

    def ddg_top_hit(self, topic, skip=()):
        """Search DuckDuckGo for a topic and return the top hit."""
        results = self.ddg_search(topic)
        for result in results:
            if result.get('href') in skip:
                continue
            html = self.fetch(result.get('href'))
            if html:
                title = self.extract_title(html)
                content = self.simplify_html(html)
                if content:
                    return result['href'], title, content
        return None, None, None

    @staticmethod
    def extract_title(html):
        """Extract the title from an HTML document."""
        soup = BeautifulSoup(html, 'html.parser')
        return soup.title.string.strip() if soup.title else "Untitled"

    @staticmethod
    def simplify_html(html):
        """Convert HTML to markdown, removing some tags and links."""
        soup = BeautifulSoup(html, 'html.parser')
        for tag in soup.find_all(["script", "style"]):
            tag.decompose()
        for tag in soup.find_all("a"):
            del tag["href"]
        for tag in soup.find_all("img"):
            del tag["src"]
        text = MarkdownConverter().convert_soup(soup)
        return re.sub(r"\n(\s*\n)+", "\n\n", text)

    @staticmethod
    def extract_json_from_markdown(markdown_text):
        """Extract JSON from Markdown-formatted string."""
        json_match = re.search(r'json\s*(\[\s*.+\s*\])\s*', markdown_text, re.DOTALL)
        if json_match:
            try:
                return json.loads(json_match.group(1).strip())
            except json.JSONDecodeError as e:
                logging.error(f"Error decoding JSON: {e}")
        logging.warning("No JSON found in Markdown.")
        return None

    def fetch_sources(self, search_prompt):
        """Fetch sources for a question."""
        try:
            search_text = prompt_llm(search_prompt)
            searches = self.extract_json_from_markdown(search_text)
            if not searches:
                logging.warning("No search topics generated by LLM.")
                return "", []
            background_text, sources = "", []
            for search in searches:
                source, title, content = self.ddg_top_hit(search, skip=[s[0] for s in sources])
                if source:
                    background_text += f"# {search}\n\n{content}\n\n"
                    sources.append((source, title))
            return background_text, sources
        except Exception as e:
            logging.error(f"Error during source fetching: {e}")
            return "", []

    def format_answer(self, answer, sources):
        """Format the answer with sources."""
        paragraphs = answer.splitlines()
        wrapped_paragraphs = [textwrap.fill(p, width=80) for p in paragraphs if p.strip()]
        sources_str = "\nSources:" + "\n".join([f"* [{title}]({url})" for url, title in sources])
        return "\n".join(wrapped_paragraphs) + "\n\n" + sources_str

    def search_topic(self, topic):
        """Search a topic and format the response."""
        try:
            today_prompt = f"Today is {datetime.date.today().strftime('%a, %b %e, %Y')}."
            search_prompt = (
                f"{today_prompt}\nPrepare for this prompt: {topic}\n\n"
                "What 3 Internet search topics would help you answer this question? "
                "Answer in a JSON list only."
            )
            background_text, sources = self.fetch_sources(search_prompt)
            summarized_text = summarize(background_text)
            answer = prompt_llm("\n".join([today_prompt, summarized_text, f"# Prompt\n{topic}"]))
            formatted_answer = self.format_answer(answer, sources)
            logging.info("Final Answer:\n" + formatted_answer)
        except Exception as e:
            logging.error(f"Error during topic search: {e}")

# Example usage
if __name__ == "__main__":
    searcher = WebSearch()
    searcher.search_topic(topic= "How do i replace the water filter in my frigidaire refrigerator?")