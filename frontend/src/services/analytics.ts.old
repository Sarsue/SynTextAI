import posthog from 'posthog-js';
import { useEffect } from 'react';

// Extend PostHog type to include flush method
declare module 'posthog-js' {
  interface PostHog {
    flush?: () => void;
  }
}

// Configuration for PostHog
export interface PostHogConfig {
  debugMode?: boolean;
  userId?: string;
  sessionId?: string;
}

/**
 * Initialize PostHog analytics
 * @param config Configuration for PostHog
 */
export function initPostHog(config: PostHogConfig = {}): typeof posthog {
  // Initialize PostHog with API key from environment variables
  const apiKey = process.env.REACT_APP_POST_HOG_API_KEY || '';
  const sessionId = config.sessionId || generateSessionId();
  
  // Initialize PostHog
  posthog.init(apiKey, {
    api_host: 'https://app.posthog.com',
    autocapture: false, // Disable automatic event capture
    capture_pageview: false, // Disable automatic pageview capture
    loaded: (ph) => {
      if (config.userId) {
        ph.identify(config.userId);
      }
      
      // Add session ID as property to all future events
      ph.register({
        session_id: sessionId
      });
      
      if (config.debugMode) {
        ph.debug();
        console.log('[PostHog] Initialized with session ID:', sessionId);
      }
    }
  });
  
  return posthog;
}

/**
 * Generate a random session ID
 */
function generateSessionId(): string {
  return Math.random().toString(36).substring(2, 15) + 
         Math.random().toString(36).substring(2, 15);
}

/**
 * Track a page view
 * @param url The URL of the page
 * @param referrer The referring URL
 */
export function trackPageView(url: string, referrer: string = document.referrer): void {
  posthog.capture('$pageview', {
    $current_url: url,
    $referrer: referrer,
    timestamp: Date.now()
  });
}

/**
 * React hook to use PostHog analytics
 */
export function usePostHog(config?: PostHogConfig): typeof posthog {
  useEffect(() => {
    // Initialize PostHog if not already initialized
    const client = initPostHog(config);
    
    return () => {
      // Flush any pending events on unmount
      if (typeof client.flush === 'function') {
        client.flush();
      }
    };
  }, []);
  
  return posthog;
}

/**
 * Export posthog instance for direct use
 */
export default posthog;
  
  private init(): void {
    // Set up heartbeat for session tracking
    this.heartbeatInterval = setInterval(() => this.checkUserActivity(), this.config.heartbeatInterval);
    
    // Track page views
    this.trackPageView();
    
    // Track clicks
    document.addEventListener('click', this.handleClick);
    
    // Track form interactions
    document.addEventListener('focus', this.handleFormFocus, true);
    document.addEventListener('blur', this.handleFormBlur, true);
    document.addEventListener('submit', this.handleFormSubmit);
    
    // Track page navigation and browser exit
    window.addEventListener('popstate', this.handleNavigation);
    window.addEventListener('beforeunload', this.handleExit);
    
    // Error tracking
    window.addEventListener('error', this.handleError);
    
    // Custom event listener for route changes in SPA
    document.addEventListener('routeChange', (e: any) => {
      if (e.detail && e.detail.path) {
        this.handleSPANavigation(e.detail.path);
      }
    });
  }
  
  public trackPageView(): void {
    const now = Date.now();
    const referrer = document.referrer || '';
    
    this.pageVisitStartTime = now;
    this.currentPath = window.location.pathname;
    
    const event: PageViewEvent = {
      type: 'pageview',
      path: this.currentPath,
      referrer,
      timestamp: now,
    };
    
    this.trackEvent(event);
  }
  
  private handleClick = (e: MouseEvent): void => {
    const target = e.target as HTMLElement;
    if (!target) return;
    
    const path = this.currentPath;
    const timestamp = Date.now();
    this.lastActivity = timestamp;
    
    // Collect element info
    let elementId = target.id || '';
    const elementType = target.tagName.toLowerCase();
    
    // Try to find a meaningful identifier if ID is not present
    if (!elementId) {
      if (target.hasAttribute('data-testid')) {
        elementId = target.getAttribute('data-testid') || '';
      } else if (target.hasAttribute('name')) {
        elementId = target.getAttribute('name') || '';
      } else if (target.hasAttribute('class')) {
        elementId = `${elementType}-${target.getAttribute('class')}`;
      } else {
        // Generate a path-like ID based on DOM structure
        const parents: string[] = [];
        let currentElem: HTMLElement | null = target;
        let depth = 0;
        
        while (currentElem && depth < 3) {
          let identifier = currentElem.id || currentElem.tagName.toLowerCase();
          if (currentElem.classList.length > 0) {
            identifier += `.${Array.from(currentElem.classList).join('.')}`;
          }
          parents.unshift(identifier);
          currentElem = currentElem.parentElement;
          depth++;
        }
        
        elementId = parents.join(' > ');
      }
    }
    
    const clickEvent: ClickEvent = {
      type: 'click',
      elementId,
      elementType,
      path,
      timestamp,
      position: { x: e.clientX, y: e.clientY },
    };
    
    // Track the click event
    this.trackEvent(clickEvent);
    
    // Add to clickEvents array for rage click detection
    this.clickEvents.push(clickEvent);
    
    // Check for rage clicks
    this.detectRageClicks();
  };
  
  private detectRageClicks(): void {
    const now = Date.now();
    const { clicks: clickThreshold, timeWindow } = this.config.rageThreshold || { clicks: 5, timeWindow: 2000 };
    
    // Filter clicks in the time window
    const recentClicks = this.clickEvents.filter(click => 
      now - click.timestamp < timeWindow
    );
    
    // If we have more recent clicks than the threshold and haven't already tracked a rage event
    if (recentClicks.length >= clickThreshold && !this.isTrackingRage) {
      this.isTrackingRage = true;
      
      // Group clicks by target
      const targets: Record<string, number> = {};
      recentClicks.forEach(click => {
        const target = click.elementId;
        targets[target] = (targets[target] || 0) + 1;
      });
      
      // Find the most frequently clicked target
      let maxTarget = '';
      let maxCount = 0;
      Object.entries(targets).forEach(([target, count]) => {
        if (count > maxCount) {
          maxTarget = target;
          maxCount = count;
        }
      });
      
      // Track rage click event
      const rageEvent: RageEvent = {
        type: 'rage',
        target: maxTarget,
        clickCount: recentClicks.length,
        timeWindow,
        timestamp: now,
      };
      
      this.trackEvent(rageEvent);
      
      // Reset rage state after a delay
      setTimeout(() => {
        this.isTrackingRage = false;
      }, timeWindow);
    }
    
    // Clean up old click events
    this.clickEvents = this.clickEvents.filter(click => 
      now - click.timestamp < (timeWindow * 2)
    );
  }
  
  private handleFormFocus = (e: FocusEvent): void => {
    const target = e.target as HTMLElement;
    if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA') {
      const form = target.closest('form');
      if (form) {
        const formId = form.id || form.getAttribute('name') || 'unknown-form';
        const formFields = form.querySelectorAll('input, select, textarea').length;
        const completedFields = Array.from(form.querySelectorAll('input, select, textarea'))
          .filter(field => (field as HTMLInputElement).value.trim() !== '').length;
        
        const formEvent: FormEvent = {
          type: 'form',
          action: completedFields === 0 ? 'start' : 'progress',
          formId,
          fieldCount: formFields,
          completedFields,
          timestamp: Date.now(),
        };
        
        this.trackEvent(formEvent);
      }
    }
  };
  
  private handleFormBlur = (e: FocusEvent): void => {
    // Track field completion and form progress
    const target = e.target as HTMLInputElement;
    if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA') {
      const form = target.closest('form');
      if (form) {
        const formId = form.id || form.getAttribute('name') || 'unknown-form';
        const formFields = form.querySelectorAll('input, select, textarea').length;
        const completedFields = Array.from(form.querySelectorAll('input, select, textarea'))
          .filter(field => (field as HTMLInputElement).value.trim() !== '').length;
        
        // Check if the user is potentially abandoning the form
        if (completedFields > 0 && completedFields < formFields) {
          const relatedTarget = e.relatedTarget as HTMLElement;
          const isStayingInForm = relatedTarget && form.contains(relatedTarget);
          
          if (!isStayingInForm) {
            // They might be abandoning the form
            const formEvent: FormEvent = {
              type: 'form',
              action: 'abandon',
              formId,
              fieldCount: formFields,
              completedFields,
              timestamp: Date.now(),
            };
            
            this.trackEvent(formEvent);
          }
        }
      }
    }
  };
  
  private handleFormSubmit = (e: Event): void => {
    const form = e.target as HTMLFormElement;
    const formId = form.id || form.getAttribute('name') || 'unknown-form';
    
    const formEvent: FormEvent = {
      type: 'form',
      action: 'complete',
      formId,
      timestamp: Date.now(),
    };
    
    this.trackEvent(formEvent);
  };
  
  private handleNavigation = (): void => {
    // Calculate time spent on previous page
    const now = Date.now();
    const timeOnPage = now - this.pageVisitStartTime;
    
    // Update the previous pageview event with time spent
    const existingEvents = this.events.filter(
      e => e.type === 'pageview' && e.path === this.currentPath
    ) as PageViewEvent[];
    
    if (existingEvents.length > 0) {
      const latestEvent = existingEvents[existingEvents.length - 1];
      latestEvent.timeOnPage = timeOnPage;
    }
    
    // Track the new page
    this.trackPageView();
  };
  
  private handleSPANavigation(newPath: string): void {
    // Calculate time spent on previous page
    const now = Date.now();
    const timeOnPage = now - this.pageVisitStartTime;
    
    // Update the previous pageview event with time spent
    const existingEvents = this.events.filter(
      e => e.type === 'pageview' && e.path === this.currentPath
    ) as PageViewEvent[];
    
    if (existingEvents.length > 0) {
      const latestEvent = existingEvents[existingEvents.length - 0];
      latestEvent.timeOnPage = timeOnPage;
    }
    
    // Update path and reset timer
    this.currentPath = newPath;
    this.pageVisitStartTime = now;
    
    // Track new page view
    const pageViewEvent: PageViewEvent = {
      type: 'pageview',
      path: newPath,
      referrer: this.currentPath,
      timestamp: now,
    };
    
    this.trackEvent(pageViewEvent);
  }
  
  private handleError = (e: ErrorEvent): void => {
    const errorEvent: ErrorEvent = {
      type: 'error',
      message: e.message || 'Unknown error',
      stack: e.error?.stack,
      timestamp: Date.now(),
      path: this.currentPath,
    };
    
    this.trackEvent(errorEvent);
  };
  
  private handleExit = (e: BeforeUnloadEvent): void => {
    const now = Date.now();
    const sessionDuration = now - this.sessionStartTime;
    const timeSinceLastActivity = now - this.lastActivity;
    
    let exitType: 'normal' | 'rage' | 'ghost' = 'normal';
    
    // Check if this is a rage quit
    const recentRageEvents = this.events.filter(
      e => e.type === 'rage' && now - e.timestamp < 5000
    );
    
    if (recentRageEvents.length > 0) {
      exitType = 'rage';
    } 
    // Check for ghosting
    else if (timeSinceLastActivity > (this.config.ghostTimeout || 180000)) {
      exitType = 'ghost';
    }
    
    const exitEvent: ExitEvent = {
      type: 'exit',
      path: this.currentPath,
      timestamp: now,
      sessionDuration,
      exitType,
    };
    
    // We need to send this immediately since the page is unloading
    this.trackEvent(exitEvent, true);
    
    // Use the Beacon API for more reliable exit event tracking
    if (navigator.sendBeacon) {
      const payload = JSON.stringify({
        events: [exitEvent],
        sessionId: this.config.sessionId,
        userId: this.config.userId,
      });
      
      navigator.sendBeacon(this.config.endpoint || '/api/analytics', payload);
    }
  };
  
  private checkUserActivity(): void {
    const now = Date.now();
    const timeSinceLastActivity = now - this.lastActivity;
    
    if (timeSinceLastActivity > (this.config.ghostTimeout || 180000)) {
      // User might have ghosted - been inactive for too long
      const exitEvent: ExitEvent = {
        type: 'exit',
        path: this.currentPath,
        timestamp: now,
        sessionDuration: now - this.sessionStartTime,
        exitType: 'ghost',
      };
      
      this.trackEvent(exitEvent);
    }
  }
  
  public trackEvent(event: AnalyticsEvent, immediate = false): void {
    // Apply sampling
    if (Math.random() > (this.config.sampleRate || 1)) {
      return;
    }
    
    // Add to buffer
    this.events.push(event);
    
    // Debug mode logs
    if (this.config.debugMode) {
      console.log('[Analytics]', event);
    }
    
    // Track event in PostHog
    this.trackEventInPostHog(event);
    
    // Send events if buffer is full or immediate is requested
    if (immediate || this.events.length >= (this.config.bufferSize || 10)) {
      this.sendEvents();
    }
  }
  
  private trackEventInPostHog(event: AnalyticsEvent): void {
    // Map our internal event format to PostHog's format
    const properties: Record<string, any> = { ...event };
    
    // Create a new object without the type property
    const { type, ...restProperties } = properties;
    
    // Map our event types to PostHog event names
    const eventName = `${event.type}_event`; // e.g. 'click_event', 'pageview_event'
    
    // Send to PostHog
    posthog.capture(eventName, restProperties);
  }
  
  private sendEvents(): void {
    if (this.events.length === 0) return;
    
    const now = Date.now();
    
    // Don't send too frequently (rate limiting)
    if (now - this.lastSentTimestamp < 1000) {
      return;
    }
    
    this.lastSentTimestamp = now;
    
    const eventsToSend = [...this.events];
    this.events = [];
    
    // Prepare the payload
    const payload = {
      events: eventsToSend,
      sessionId: this.config.sessionId,
      userId: this.config.userId,
      timestamp: now,
    };
    
    // Send analytics data
    fetch(this.config.endpoint || '/api/analytics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
      // Keep-alive can improve performance for frequent requests
      keepalive: true,
    }).catch(error => {
      if (this.config.debugMode) {
        console.error('[Analytics] Failed to send events', error);
      }
      // Put events back in the queue if sending fails
      this.events = [...eventsToSend, ...this.events];
    });
  }
  
  public cleanup(): void {
    // Remove all event listeners
    document.removeEventListener('click', this.handleClick);
    document.removeEventListener('focus', this.handleFormFocus, true);
    document.removeEventListener('blur', this.handleFormBlur, true);
    document.removeEventListener('submit', this.handleFormSubmit);
    window.removeEventListener('popstate', this.handleNavigation);
    window.removeEventListener('beforeunload', this.handleExit);
    window.removeEventListener('error', this.handleError);
    document.removeEventListener('routeChange', this.handleNavigation);
    
    // Clear intervals
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }
    
    // Send any remaining events
    this.sendEvents();
    
    // Optionally flush PostHog events if method exists
    if (typeof posthog.flush === 'function') {
      posthog.flush();
    }
  }
}

// Singleton instance
let analyticsInstance: AnalyticsService;

export const initAnalytics = (config?: AnalyticsConfig): AnalyticsService => {
  if (!analyticsInstance) {
    analyticsInstance = new AnalyticsService(config);
  }
  return analyticsInstance;
};

export const getAnalytics = (): AnalyticsService => {
  if (!analyticsInstance) {
    throw new Error('Analytics not initialized. Call initAnalytics first.');
  }
  return analyticsInstance;
};

// React hook for easy integration
export const useAnalytics = (config?: AnalyticsConfig) => {
  useEffect(() => {
    // Initialize analytics on component mount
    const analytics = initAnalytics(config);
    
    // Clean up on unmount
    return () => {
      analytics.cleanup();
    };
  }, []);
  
  return getAnalytics();
};

// Export PostHog directly for advanced use cases
export { posthog };

export default {
  initAnalytics,
  getAnalytics,
  useAnalytics,
};
